/*
 * Generator.h
 *
 *  Created on: Jul 8, 2016
 *      Author: mad
 */

#ifndef INCLUDE_CPP_GENERATOR_H_
#define INCLUDE_CPP_GENERATOR_H_

#include "../Backend.h"

#define TYPE_TREE(source) \
	Void* p_void = dynamic_cast<Void*>(source); \
	Primitive* p_primitive = dynamic_cast<Primitive*>(source); \
	Bool* p_bool = dynamic_cast<Bool*>(source); \
	Integer* p_int = dynamic_cast<Integer*>(source); \
	Real* p_real = dynamic_cast<Real*>(source); \
	Array* p_array = dynamic_cast<Array*>(source); \
	Enum* p_enum = dynamic_cast<Enum*>(source); \
	Struct* p_struct = dynamic_cast<Struct*>(source); \
	Class* p_class = dynamic_cast<Class*>(source); \
	Interface* p_interface = dynamic_cast<Interface*>(source); \
	Object* p_object = dynamic_cast<Object*>(source); \
	Node* p_node = dynamic_cast<Node*>(source);


namespace vni {
namespace codegen {
namespace cpp {

class Generator : public Backend {
public:
	virtual void generate() {
		
	}
	
	static string full(string name) {
		return subs(name, ".", "::");
	}
	
	static string full(Base* type) {
		return subs(type->get_full_name(), ".", "::");
	}
	
	static string hash(Base* type) {
		char buf[64];
		int len = snprintf(buf, 64, "0x%x", (uint32_t)type->get_hash());
		return string(buf, len);
	}
	
	void echo_type(Base* type) {
		TYPE_TREE(type);
		if(p_object) {
			out << full(type) << "::Client ";
		} else if(p_struct) {
			out << full(type) << " ";
		} else if(p_enum) {
			out << full(type) << " ";
		} else if(p_array) {
			echo_type(p_array);
		} else if(p_bool) {
			out << "bool";
		} else if(p_int) {
			switch(p_int->size) {
				case 1: out << "int8_t"; break;
				case 2: out << "int16_t"; break;
				case 4: out << "int32_t"; break;
				case 8: out << "int64_t"; break;
				default: out << "<?>"; break;
			}
		} else if(p_real) {
			switch(p_real->size) {
				case 4: out << "float"; break;
				case 8: out << "double"; break;
				default: out << "<?>"; break;
			}
		} else if(p_void) {
			out << "void";
		}
	}
	
	void echo_tmpl(vector<Base*>& params) {
		if(params.size()) {
			out << "<";
			for(int i = 0; i < params.size(); ++i) {
				out << full(params[i]);
				if(i < params.size()-1) {
					out << ", ";
				}
			}
			out << ">";
		}
	}
	
	void echo_field(Field* field, bool def, bool init) {
		TYPE_TREE(field->type);
		if(def) {
			echo_type(field->type);
			echo_tmpl(field->tmpl_types);
			if(p_class && !p_interface) {
				out << "*";
			}
			out << " ";
		}
		out << field->name;
		if(init) {
			if(p_primitive) {
				out << " = " << field->value;
			} else if(p_class && !p_interface) {
				out << " = 0";
			}
		}
		if(p_array) {
			out << "[" << p_array->size << "]";
		}
		out << ";" << endl;
	}
	
	void delete_field(Field* field) {
		Class* p_class = dynamic_cast<Class*>(field->type);
		if(p_class) {
			out << "vni::destroy(" << field->name << ");" << endl;
		}
	}
	
	void generate_header(Type* p_type) {
		TYPE_TREE(p_type);
		string guard_sym = "INCLUDE_CPP_GENERATED_" + subs(p_type->get_full_name(), ".", "_") + "_H_";
		out.clear();
		out << endl << "#ifndef " << guard_sym << endl;
		out << "#define " << guard_sym << endl << endl;
		out << "// AUTO GENERATED by virtual-network-interface codegen" << endl << endl;
		
		is_base = p_type->get_full_name() == "vni.Value";
		for(string import : p_type->imports) {
			if(is_base && import == "vni.Value") {
				import = "vni.Type";
			}
			out << "#include <" << subs(import, ".", "/") << ".h>" << endl;
		}
		out << endl;
		
		namespaces = split(p_type->package->name, '.');
		for(string space : namespaces) {
			out << "namespace " << space << " {" << endl;
		}
		
		if(p_struct) {
			out << endl << "class " << p_struct->name << " ";
		}
		if(p_class) {
			out << ": public ";
			if(p_class->super) {
				out << full(p_class->super);
			} else if(!is_base) {
				out << "vni::Value ";
			} else {
				out << "vni::Type ";
			}
		}
		out << "{" << endl;
		
		if(p_struct) {
			out << "public:@" << endl;
			out << "static const uint32_t VNI_HASH = " << hash(p_type) << ";" << endl;
			out << "static const uint32_t NUM_FIELDS = " << p_struct->fields.size() << ";" << endl << endl;
			
			for(Field* field : p_struct->fields) {
				echo_field(field, true, false);
			}
			
			out << p_type->name << "() {@" << endl;
			for(Field* field : p_struct->fields) {
				echo_field(field, false, true);
			}
			out << "$}" << endl;
			out << "~" << p_type->name << "() {@" << endl;
			for(Field* field : p_struct->fields) {
				delete_field(field);
			}
			out << "$}" << endl << endl;
		}
		
		if(p_class) {
			out << "static " << p_type->name << "* create(vnl::Hash32 hash);" << endl;
		}
		if(p_struct) {
			out << "static " << p_type->name << "* create() { return vni::create<" << p_type->name << ">(); }" << endl << endl;
			out << p_type->name << "& operator=(const " << p_type->name << "& other);" << endl << endl;
			out << "virtual " << p_type->name << "* clone() { return vni::create<" << p_type->name << ">(*this); }" << endl;
			out << "virtual void destroy() { vni::destroy<" << p_type->name << ">(this); }" << endl << endl;
			out << "virtual uint32_t vni_hash() const { return VNI_HASH; }" << endl;
			out << "virtual const char* type_name() const { return \"" << p_type->get_full_name() << "\"; }" << endl;
		}
		if(p_class) {
			out << "virtual bool is_base(vnl::Hash32 hash) const;" << endl;
			out << "virtual bool is_instance(vnl::Hash32 hash) const;" << endl << endl;
		}
		if(p_struct) {
			out << "virtual int num_fields() const { return NUM_FIELDS; }" << endl;
			out << "virtual int field_index(vnl::Hash32 hash) const;" << endl;
			out << "virtual const char* field_name(int index) const;" << endl;
			out << "virtual " << p_type->name << "* field_type(int index) const;" << endl;
			out << "virtual void serialize(vnl::io::TypeOutput& out) const;" << endl;
			out << "virtual void deserialize(vnl::io::TypeInput& in, int size);" << endl;
		}
		
		if(p_enum) {
			// TODO
		}
		
		out << endl << "$};" << endl << endl;
		for(string space : namespaces) {
			out << "} // " << space << endl;
		}
		out << endl << "#endif // " << guard_sym << endl;
	}
	
	void generate_source(Type* p_type) {
		// TODO
	}
	
	bool is_base = false;
	vector<string> namespaces;
	ostringstream out;
	
};




}}}

#endif /* INCLUDE_CPP_GENERATOR_H_ */
